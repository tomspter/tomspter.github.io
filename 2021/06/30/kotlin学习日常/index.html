<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>kotlin学习日常</title><meta name="description" content="LILAC"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-M81Y3VGZFG', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'a54d6e0d3f581d89bfc0bf66e893b891';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="kotlin学习，日常随机更新，目标是学完kotlin和ktor，直接上代码片段

基础部分fun main() {
    /*
    定义变量时可选用增强的类型推导
    val 只读对象，但引用对象可更改，优先使用
    var
     */
    val str = &quot;Hello, world!!!&quot;
    val strType: String = &quot;Hello, world!!!&quot;
    println(str)
    println(strType)

    /*
    代码块函数体，必须声明函数返回类型
    Unit类型
     */
    fun sum(x: Int, y: Int): Int {
        return x + y
    }

   .."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Tomspter's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">kotlin学习日常</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-text">基础部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Kotlin"><i class="tag post-item-tag">Kotlin</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">kotlin学习日常</h1><time class="has-text-grey" datetime="2021-06-30T09:02:25.000Z">2021-06-30</time><article class="mt-2 post-content"><p><img src="https://source.unsplash.com/random/800x400?universe" alt="cover"><br>kotlin学习，日常随机更新，目标是学完kotlin和ktor，直接上代码片段</p>
<span id="more"></span>
<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><pre><code class="kotlin">fun main() {
    /*
    定义变量时可选用增强的类型推导
    val 只读对象，但引用对象可更改，优先使用
    var
     */
    val str = "Hello, world!!!"
    val strType: String = "Hello, world!!!"
    println(str)
    println(strType)

    /*
    代码块函数体，必须声明函数返回类型
    Unit类型
     */
    fun sum(x: Int, y: Int): Int {
        return x + y
    }

    /*
    表达式函数体，可以不声明返回值类型
    全局类型推导：在有递归等复杂条件下需要显式声明类型
     */
    fun sumLine(x: Int, y: Int) = x + y

    fun foo(x: Int): Int = if (x == 0) 1 else x * foo(x - 1)

    println("sum " + sum(1, 2))
    println("sumLine " + sumLine(1, 2))
    println("foo " + foo(2))


    class CheckNum {
        fun filter(numList: List&lt;Int&gt;, checkNum: (Int) -&gt; Boolean): List&lt;Int&gt; {
            val res = mutableListOf&lt;Int&gt;()
            for (n in numList) {
                if (checkNum(n)) {
                    res.add(n)
                }
            }
            return res
        }
    }

    class CheckNumCondition {
        fun isLarge10(num: Int) = num &lt;= 10
        fun isSmall5(num: Int) = num &gt;= 5
    }

    val numList = listOf(1, 3, 5, 7, 9, 11, 13)
    val checkClass = CheckNum()
    val checkCondition = CheckNumCondition()
    /*
    双冒号语法，可以定义一个类的构造方法引用变量，或引用某个类中的成员变量
     */
    println(checkClass.filter(numList, checkCondition::isLarge10))
    println(checkClass.filter(numList, checkCondition::isSmall5))
    /*
    匿名函数，缺省函数名
     */
    println(checkClass.filter(numList, fun(num: Int): Boolean = num &lt;= 10))
    /*
    lambda表达式,支持类型推导,可访问外部变量，可自运行
     */
    println(checkClass.filter(numList) { num -&gt; num &lt;= 10 })

    var sum = 0
    listOf(1, 2, 3).filter { it &gt; 0 }.forEach { sum += it }
    println(sum)
//    {x:Int-&gt; println(x)}(1)

    /*
    it语法糖:单个参数的隐式名称
     */
    fun printIntFoo(int: Int) = print(int)
    listOf(1, 2, 3).forEach { item -&gt; printIntFoo(item) }
    listOf(1, 2, 3).forEach { printIntFoo(it) }

    /*
    链式柯里化,将接收多个参数的函数变换成一系列仅接收单一参数函数的过程
     */
    fun sumXYZ(x: Int, y: Int, z: Int) = x + y + z
    println("\n" + sumXYZ(2, 3, 4))
    fun sumCurry(x: Int) = { y: Int -&gt; { z: Int -&gt; x + y + z } }
    println(sumCurry(2)(3)(4))

    /*
    ?: 语法糖:Elvis运算符
     */
    val maybeInt: Int? = null
    println(maybeInt ?: 1)

    println(DayOfWeek.TUE.getDayNumber())

    /*
    when: 由上到下匹配，一直匹配完成位置，否则进入else分支。when的返回类型是所有分支相同的返回类型或公开的父类型
     */
    fun schedule(isSunny: Boolean, day: DayOfWeek) = when (day) {
        DayOfWeek.MON -&gt; println("basketball")
        DayOfWeek.TUE -&gt; println("fishing")
        else -&gt; when {
            isSunny -&gt; println("library")
            else -&gt; println("study")
        }
    }

    fun scheduleSimplify(isSunny: Boolean, day: DayOfWeek) = when {
        day == DayOfWeek.MON -&gt; println("basketball")
        day == DayOfWeek.TUE -&gt; println("fishing")
        isSunny -&gt; println("library")
        else -&gt; println("study")
    }

    /*
    for循环
    .. : 范围表达式,除整形外，需要实现java.lang.Comparable接口
    step : 迭代步长
    downTo : 倒序
    until : 半开区间
     */
    for (i in 1..5) print(i)
    println()
    for (i in 1..5 step 2) print(i)
    println()
    for (i in 10 downTo 1 step 2) print(i)
    println()
    for (i in 1 until 5) print(i)

    /*
    in关键字检查成员关系,!取反
     */
    println(1 !in arrayOf(1, 2, 3))
    println(1 in 3..5)

    /*
    函数可变参数,Kotlin中没有限制可变参数在最后一个位置
    可以使用*来传入外部变量作为可变参数变量
     */
    val sums = intArrayOf(1, 2, 3, 4, 5)
    fun varargSum(vararg nums: Int) = nums.sumOf { it }
    println("varargSum  ${varargSum(1, 2, 3, 4, 5)}")
    println("varargSum* ${varargSum(*sums)}")

    /*
    中缀表达式： 形如 A 中缀方法 B
    必须满足以下条件，中缀函数参数只有一个，参数不能是默认值，参数不能是可变参数
     */
    mapOf(
        1 to "one",
        2 to "two",
        3 to "three"
    )

    class Person {
        infix fun called(name: String) {
            println("name is ${name}.")
        }
    }

    val person = Person()
    person called "tomspter"
    person.called("tomspter2")

    /*
    字符串，三个引号表示多行，不会发生转义
    字符串判断，== 判断内容是否相等，=== 判断引用是否一样
     */
}

/*
枚举类,存在额外的方法或属性定义，强制添加分号
 */
enum class DayOfWeek(private val day: Int) {
    MON(1),
    TUE(2),
    WEN(3);

    fun getDayNumber(): Int = day
}
/*
建议
1.尽可能使用val，不可变对象和纯函数来设计程序
 */
</code></pre>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre><code class="kotlin">import kotlin.properties.Delegates

/*
val修饰不可变属性成员
需要指定属性默认值，除显式声明延迟初始化
不同种类可访问修饰符
带有属性和默认方法接口
 */
class Bird(color: String, age: Int) {
    val weight: Double = 500.0
    var color: String = "blue"
    var age: Int = 1
    var sex: String

    /*
    延迟初始化
    lazy:
    变量是引用不可变的，首次调用的时候才会进行赋值，赋值后不会在更改
    原理：接受一个lambda并返回一个Lazy&lt;T&gt;实例的函数，第一次访问该属性时，会执行lazy对应的Lambda表达式并记录结果，后续访问该属性时只是返回记录的结果
    默认加上同步锁，同一时刻只有一个线程可以初始化属性
    LazyThreadSafetyMode.PUBLICATION 并行模式
    LazyThreadSafetyMode.None 不做任何线程保证

    lateinit:
    用于var声明的变量，不能用于基本数据类型(基本数据类型延迟加载见下面varLazyInit例子)
    正常情况下，类中所有非抽象属性成员必须在对象创建时被初始化，使用延时加载可以避免
     */
    val sexLazy: String by lazy {
        if (this.color == "yellow") "male" else "female"
    }
    val sexLazyNoSafe: String by lazy(LazyThreadSafetyMode.PUBLICATION) {
        if (this.color == "yellow") "male" else "female"
    }
    lateinit var sexLateInit: String
    fun fly() {}
    fun printSex() {
        this.sexLateInit = if (this.color == "yellow") "male" else "female"
        println(this.sexLateInit)
    }


    //可以有多个init，从上到下顺序执行
    init {
        println("init...")
        this.color = color
        this.age = age
    }

    init {
        this.sex = if (this.color == "yellow") "male" else "female"
    }
}

open class BirdBase {
    open fun fly() = println("fly...")
}

/*
继承
使用:表示继承关系
方法默认不可被继承，重写，open修饰符相反
 */
class Pemguin : BirdBase() {
    override fun fly() {
        super.fly()
        println("Pemguin fly...")
    }
}

/*
密封类
 */
sealed class BirdSealedBase {
    open fun fly() = println("fly...")
}

/*
创建对象简写方式
 */
class Dog(weight: Double = 0.00, age: Int = 0, color: String = "blue")

val dog = Dog(10.0, 3, "GREY")

/*
接口实现多继承
super指定继承父接口方法
 */
interface Flyer {
    fun fly()
    fun kind() = println("Flyer")
}

interface Animal {
    val name: String
    fun eat()
    fun kind() = println("Animal")
}

class Cat(override val name: String) : Flyer, Animal {
    override fun fly() = println("cat fly...")

    override fun kind() = super&lt;Flyer&gt;.kind()

    override fun eat() = println("cat eat...")
}

/*
内部类实现多继承
内部类包含着对其外部类实例的引用，在内部类中我们可以使用外部类中的属性
嵌套类不包含对其外部类实例的引用，所以它无法调用其外部类的属性
一个类内部定义多个内部类，每个内部类的实例都有自己的独立状态，它们与外部对象的信息相互独立
 */
open class Horse {
    fun run() = println("Horse run")
}

open class Donkey {
    fun dosome() = println("Donkey dosome")
}

class Mule {
    fun run() = HorseC().run()
    fun dosome() = DonkeyC().dosome()
    private inner class HorseC : Horse()
    private inner class DonkeyC : Donkey()
}

/*
委托实现多继承
不推荐在接口中实现复杂的方法逻辑，保证接口无状态
假设我们需要继承的类是A，委托对象是B、C、我们在具体调用的时候并不是像组合一样A.B.method，而是可以直接调用A.method，这更能表达A拥有该method的能力，更加直观
 */
interface CanFly {
    fun fly()
}

interface CanEat {
    fun eat()
}

open class Flyer2 : CanFly {
    override fun fly() = println("Flyer2")
}

open class Eater2 : CanEat {
    override fun eat() = println("Eater2")
}

class Bird2(flyer2: Flyer2, eater2: Eater2) : CanFly by flyer2, CanEat by eater2 {}

/*
数据类
基本等同与lombok的@Data注解
特殊方法copy与componentN
copy: 基于原有对象生成一个新的对象,浅拷贝。注意使用场景，因为数据类的属性可以被修饰为var，这便不能保证不会出现引用修改问题
componentN: 解构
 */
data class DogModel(var weight: Double, var age: Int, var color: String)

/*
伴生类
包裹了所有静态属性和方法与普通方法和属性明显分开
使用伴生类实现工厂模式,不需要每次获取对象时重新创建对象
使用伴生类实现单例模式,object全局声明对象只有一个
 */
class Prize(val name: String, val count: Int, val type: Int) {
    companion object {
        val TYPE_REDPACK = 0
        val TYPE_COUPON = 1
        val defaultPrize = Prize("default", 10, TYPE_COUPON)
        fun redPackPrize(name: String, count: Int) = Prize(name, count, TYPE_REDPACK)
        fun couponPrize(name: String, count: Int) = Prize(name, count, TYPE_COUPON)
        fun defaultCommonPrize() = defaultPrize
        fun isRedpack(prize: Prize): Boolean = prize.type == TYPE_REDPACK
    }
}

object DataBaseConfig{
    var host:String = "127.0.0.1"
}


fun main() {
    val bird = Bird(color = "yellow", age = 10)
    println(bird.sex)
    bird.printSex()

    /*
    var声明的基本数据类型也具有延迟初始化效果
     */
    var varLazyInit by Delegates.notNull&lt;Int&gt;()
    fun doSomething() {
        varLazyInit = 1
        println("varLazyInit value is ${varLazyInit}")
        varLazyInit = 2
    }
    doSomething()
    val cat = Cat("tom")
    cat.fly()
    cat.kind()

    Mule().run()

    val flyer2 = Flyer2()
    val eater2 = Eater2()
    val b = Bird2(flyer2, eater2)
    b.eat()
    b.fly()

    val dogmodel1 = DogModel(10.0, 1, "grey")
    val dogmodel2 = dogmodel1
    dogmodel2.age = 3
    println("dogmodel1 age is ${dogmodel1.age}. dogmodel2 age is ${dogmodel2.age}")
    var dogmodel3 = dogmodel1.copy(age = 5)
    println("dogmodel1 age is ${dogmodel1.age}. dogmodel2 age is ${dogmodel2.age}. dogmodel3 age is ${dogmodel3.age}\"")

    val (weight, age, color) = DogModel(30.0, 2, "BLACK")
    println(weight)

    val prize = Prize("RED", 10, Prize.TYPE_REDPACK)
    println(Prize.isRedpack(prize))
    val redPrize = Prize.redPackPrize("red",20)
    //默认实现
    val defaultPrize = Prize.defaultCommonPrize()
}

/*
提示
1）在Kotlin中实现一个接口时，需要实现接口中没有默认实现的方法及未初始化的属性，若同时实现多个接口，而接口间又有相同方法名的默认实现时，则需要主动指定使用哪个接口的方法或者重写方法；
2）如果是默认的接口方法，你可以在实现类中通过“super&lt;T&gt;”这种方式调用它，其中T为拥有该方法的接口名；
3）在实现接口的属性和方法时，都必须带上override关键字，不能省略。
 */
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2021/06/29/kibana%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/" title="kibana查询时间问题"><span class="has-text-weight-semibold">Next: kibana查询时间问题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Tomspter/tomspter.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/tomspter"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Tomspter 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>