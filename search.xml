<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kotlin学习日常</title>
      <link href="/2021/06/30/kotlin%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/"/>
      <url>/2021/06/30/kotlin%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://source.unsplash.com/random/800x400?universe" alt="cover"><br>kotlin学习，日常随机更新，目标是学完kotlin和ktor，直接上代码片段</p><span id="more"></span><h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><pre><code class="kotlin">fun main() {    /*    定义变量时可选用增强的类型推导    val 只读对象，但引用对象可更改，优先使用    var     */    val str = "Hello, world!!!"    val strType: String = "Hello, world!!!"    println(str)    println(strType)    /*    代码块函数体，必须声明函数返回类型    Unit类型     */    fun sum(x: Int, y: Int): Int {        return x + y    }    /*    表达式函数体，可以不声明返回值类型    全局类型推导：在有递归等复杂条件下需要显式声明类型     */    fun sumLine(x: Int, y: Int) = x + y    fun foo(x: Int): Int = if (x == 0) 1 else x * foo(x - 1)    println("sum " + sum(1, 2))    println("sumLine " + sumLine(1, 2))    println("foo " + foo(2))    class CheckNum {        fun filter(numList: List&lt;Int&gt;, checkNum: (Int) -&gt; Boolean): List&lt;Int&gt; {            val res = mutableListOf&lt;Int&gt;()            for (n in numList) {                if (checkNum(n)) {                    res.add(n)                }            }            return res        }    }    class CheckNumCondition {        fun isLarge10(num: Int) = num &lt;= 10        fun isSmall5(num: Int) = num &gt;= 5    }    val numList = listOf(1, 3, 5, 7, 9, 11, 13)    val checkClass = CheckNum()    val checkCondition = CheckNumCondition()    /*    双冒号语法，可以定义一个类的构造方法引用变量，或引用某个类中的成员变量     */    println(checkClass.filter(numList, checkCondition::isLarge10))    println(checkClass.filter(numList, checkCondition::isSmall5))    /*    匿名函数，缺省函数名     */    println(checkClass.filter(numList, fun(num: Int): Boolean = num &lt;= 10))    /*    lambda表达式,支持类型推导,可访问外部变量，可自运行     */    println(checkClass.filter(numList) { num -&gt; num &lt;= 10 })    var sum = 0    listOf(1, 2, 3).filter { it &gt; 0 }.forEach { sum += it }    println(sum)//    {x:Int-&gt; println(x)}(1)    /*    it语法糖:单个参数的隐式名称     */    fun printIntFoo(int: Int) = print(int)    listOf(1, 2, 3).forEach { item -&gt; printIntFoo(item) }    listOf(1, 2, 3).forEach { printIntFoo(it) }    /*    链式柯里化,将接收多个参数的函数变换成一系列仅接收单一参数函数的过程     */    fun sumXYZ(x: Int, y: Int, z: Int) = x + y + z    println("\n" + sumXYZ(2, 3, 4))    fun sumCurry(x: Int) = { y: Int -&gt; { z: Int -&gt; x + y + z } }    println(sumCurry(2)(3)(4))    /*    ?: 语法糖:Elvis运算符     */    val maybeInt: Int? = null    println(maybeInt ?: 1)    println(DayOfWeek.TUE.getDayNumber())    /*    when: 由上到下匹配，一直匹配完成位置，否则进入else分支。when的返回类型是所有分支相同的返回类型或公开的父类型     */    fun schedule(isSunny: Boolean, day: DayOfWeek) = when (day) {        DayOfWeek.MON -&gt; println("basketball")        DayOfWeek.TUE -&gt; println("fishing")        else -&gt; when {            isSunny -&gt; println("library")            else -&gt; println("study")        }    }    fun scheduleSimplify(isSunny: Boolean, day: DayOfWeek) = when {        day == DayOfWeek.MON -&gt; println("basketball")        day == DayOfWeek.TUE -&gt; println("fishing")        isSunny -&gt; println("library")        else -&gt; println("study")    }    /*    for循环    .. : 范围表达式,除整形外，需要实现java.lang.Comparable接口    step : 迭代步长    downTo : 倒序    until : 半开区间     */    for (i in 1..5) print(i)    println()    for (i in 1..5 step 2) print(i)    println()    for (i in 10 downTo 1 step 2) print(i)    println()    for (i in 1 until 5) print(i)    /*    in关键字检查成员关系,!取反     */    println(1 !in arrayOf(1, 2, 3))    println(1 in 3..5)    /*    函数可变参数,Kotlin中没有限制可变参数在最后一个位置    可以使用*来传入外部变量作为可变参数变量     */    val sums = intArrayOf(1, 2, 3, 4, 5)    fun varargSum(vararg nums: Int) = nums.sumOf { it }    println("varargSum  ${varargSum(1, 2, 3, 4, 5)}")    println("varargSum* ${varargSum(*sums)}")    /*    中缀表达式： 形如 A 中缀方法 B    必须满足以下条件，中缀函数参数只有一个，参数不能是默认值，参数不能是可变参数     */    mapOf(        1 to "one",        2 to "two",        3 to "three"    )    class Person {        infix fun called(name: String) {            println("name is ${name}.")        }    }    val person = Person()    person called "tomspter"    person.called("tomspter2")    /*    字符串，三个引号表示多行，不会发生转义    字符串判断，== 判断内容是否相等，=== 判断引用是否一样     */}/*枚举类,存在额外的方法或属性定义，强制添加分号 */enum class DayOfWeek(private val day: Int) {    MON(1),    TUE(2),    WEN(3);    fun getDayNumber(): Int = day}/*建议1.尽可能使用val，不可变对象和纯函数来设计程序 */</code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre><code class="kotlin">import kotlin.properties.Delegates/*val修饰不可变属性成员需要指定属性默认值，除显式声明延迟初始化不同种类可访问修饰符带有属性和默认方法接口 */class Bird(color: String, age: Int) {    val weight: Double = 500.0    var color: String = "blue"    var age: Int = 1    var sex: String    /*    延迟初始化    lazy:    变量是引用不可变的，首次调用的时候才会进行赋值，赋值后不会在更改    原理：接受一个lambda并返回一个Lazy&lt;T&gt;实例的函数，第一次访问该属性时，会执行lazy对应的Lambda表达式并记录结果，后续访问该属性时只是返回记录的结果    默认加上同步锁，同一时刻只有一个线程可以初始化属性    LazyThreadSafetyMode.PUBLICATION 并行模式    LazyThreadSafetyMode.None 不做任何线程保证    lateinit:    用于var声明的变量，不能用于基本数据类型(基本数据类型延迟加载见下面varLazyInit例子)    正常情况下，类中所有非抽象属性成员必须在对象创建时被初始化，使用延时加载可以避免     */    val sexLazy: String by lazy {        if (this.color == "yellow") "male" else "female"    }    val sexLazyNoSafe: String by lazy(LazyThreadSafetyMode.PUBLICATION) {        if (this.color == "yellow") "male" else "female"    }    lateinit var sexLateInit: String    fun fly() {}    fun printSex() {        this.sexLateInit = if (this.color == "yellow") "male" else "female"        println(this.sexLateInit)    }    //可以有多个init，从上到下顺序执行    init {        println("init...")        this.color = color        this.age = age    }    init {        this.sex = if (this.color == "yellow") "male" else "female"    }}open class BirdBase {    open fun fly() = println("fly...")}/*继承使用:表示继承关系方法默认不可被继承，重写，open修饰符相反 */class Pemguin : BirdBase() {    override fun fly() {        super.fly()        println("Pemguin fly...")    }}/*密封类 */sealed class BirdSealedBase {    open fun fly() = println("fly...")}/*创建对象简写方式 */class Dog(weight: Double = 0.00, age: Int = 0, color: String = "blue")val dog = Dog(10.0, 3, "GREY")/*接口实现多继承super指定继承父接口方法 */interface Flyer {    fun fly()    fun kind() = println("Flyer")}interface Animal {    val name: String    fun eat()    fun kind() = println("Animal")}class Cat(override val name: String) : Flyer, Animal {    override fun fly() = println("cat fly...")    override fun kind() = super&lt;Flyer&gt;.kind()    override fun eat() = println("cat eat...")}/*内部类实现多继承内部类包含着对其外部类实例的引用，在内部类中我们可以使用外部类中的属性嵌套类不包含对其外部类实例的引用，所以它无法调用其外部类的属性一个类内部定义多个内部类，每个内部类的实例都有自己的独立状态，它们与外部对象的信息相互独立 */open class Horse {    fun run() = println("Horse run")}open class Donkey {    fun dosome() = println("Donkey dosome")}class Mule {    fun run() = HorseC().run()    fun dosome() = DonkeyC().dosome()    private inner class HorseC : Horse()    private inner class DonkeyC : Donkey()}/*委托实现多继承不推荐在接口中实现复杂的方法逻辑，保证接口无状态假设我们需要继承的类是A，委托对象是B、C、我们在具体调用的时候并不是像组合一样A.B.method，而是可以直接调用A.method，这更能表达A拥有该method的能力，更加直观 */interface CanFly {    fun fly()}interface CanEat {    fun eat()}open class Flyer2 : CanFly {    override fun fly() = println("Flyer2")}open class Eater2 : CanEat {    override fun eat() = println("Eater2")}class Bird2(flyer2: Flyer2, eater2: Eater2) : CanFly by flyer2, CanEat by eater2 {}/*数据类基本等同与lombok的@Data注解特殊方法copy与componentNcopy: 基于原有对象生成一个新的对象,浅拷贝。注意使用场景，因为数据类的属性可以被修饰为var，这便不能保证不会出现引用修改问题componentN: 解构 */data class DogModel(var weight: Double, var age: Int, var color: String)/*伴生类包裹了所有静态属性和方法与普通方法和属性明显分开使用伴生类实现工厂模式,不需要每次获取对象时重新创建对象使用伴生类实现单例模式,object全局声明对象只有一个 */class Prize(val name: String, val count: Int, val type: Int) {    companion object {        val TYPE_REDPACK = 0        val TYPE_COUPON = 1        val defaultPrize = Prize("default", 10, TYPE_COUPON)        fun redPackPrize(name: String, count: Int) = Prize(name, count, TYPE_REDPACK)        fun couponPrize(name: String, count: Int) = Prize(name, count, TYPE_COUPON)        fun defaultCommonPrize() = defaultPrize        fun isRedpack(prize: Prize): Boolean = prize.type == TYPE_REDPACK    }}object DataBaseConfig{    var host:String = "127.0.0.1"}fun main() {    val bird = Bird(color = "yellow", age = 10)    println(bird.sex)    bird.printSex()    /*    var声明的基本数据类型也具有延迟初始化效果     */    var varLazyInit by Delegates.notNull&lt;Int&gt;()    fun doSomething() {        varLazyInit = 1        println("varLazyInit value is ${varLazyInit}")        varLazyInit = 2    }    doSomething()    val cat = Cat("tom")    cat.fly()    cat.kind()    Mule().run()    val flyer2 = Flyer2()    val eater2 = Eater2()    val b = Bird2(flyer2, eater2)    b.eat()    b.fly()    val dogmodel1 = DogModel(10.0, 1, "grey")    val dogmodel2 = dogmodel1    dogmodel2.age = 3    println("dogmodel1 age is ${dogmodel1.age}. dogmodel2 age is ${dogmodel2.age}")    var dogmodel3 = dogmodel1.copy(age = 5)    println("dogmodel1 age is ${dogmodel1.age}. dogmodel2 age is ${dogmodel2.age}. dogmodel3 age is ${dogmodel3.age}\"")    val (weight, age, color) = DogModel(30.0, 2, "BLACK")    println(weight)    val prize = Prize("RED", 10, Prize.TYPE_REDPACK)    println(Prize.isRedpack(prize))    val redPrize = Prize.redPackPrize("red",20)    //默认实现    val defaultPrize = Prize.defaultCommonPrize()}/*提示1）在Kotlin中实现一个接口时，需要实现接口中没有默认实现的方法及未初始化的属性，若同时实现多个接口，而接口间又有相同方法名的默认实现时，则需要主动指定使用哪个接口的方法或者重写方法；2）如果是默认的接口方法，你可以在实现类中通过“super&lt;T&gt;”这种方式调用它，其中T为拥有该方法的接口名；3）在实现接口的属性和方法时，都必须带上override关键字，不能省略。 */</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kibana查询时间问题</title>
      <link href="/2021/06/29/kibana%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/29/kibana%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://source.unsplash.com/random/800x400?universe" alt="cover"></p><h2 id="kibana查询时间问题"><a href="#kibana查询时间问题" class="headerlink" title="kibana查询时间问题"></a>kibana查询时间问题</h2><p>通过Kibana展示ES数据的时候，会有八个小时的时间差，根据网上的搜索结果来看，原因是Kibana在读取时间的时候没有找到时区信息，所以统一将时间默认为UTC时间，其中主流的修改方法是将Kibana设置中的Timezone for date formatting选项设置成UTC。但是经过查看后发现，日期选择功能没有问题，但最近时间选项是根据UTC时间走的，并不能根本性的解决问题。在写ES的时候就将时间保存为带有时间格式的，这样当Kibana读取到时间的时候能自动调整时间。</p><p>ES文档是通过Python消费Kafka数据存储的。因为Kafka信息中time字段是没有时区的，格式都是YYYY-mm-DD HH:mm:ss。所以目标就是通过Python将时间加上时区</p><h3 id="解决部分"><a href="#解决部分" class="headerlink" title="解决部分"></a>解决部分</h3><pre><code class="python">model_json["time"] = datetime.strptime(model_json["time"], "%Y-%m-%d %H:%M:%S") \                    .replace(tzinfo=timezone(timedelta(hours=8))) \                    .strftime("%Y-%m-%d %H:%M:%S%z")</code></pre><h3 id="Python-API"><a href="#Python-API" class="headerlink" title="Python API"></a>Python API</h3><ul><li><strong>datetime.strptime()</strong> 将字符串转换成datetime对象</li><li><strong>datetime.strftime()</strong> 将date,datetime和time转换成字符串</li><li><strong>datetime.replace()</strong> 修改datetime中属性值包括tzinfo</li><li><strong>timezone()</strong> </li><li><strong>timedelta()</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python测试</title>
      <link href="/2021/06/28/python%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/28/python%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/tomspter/image@main/img/20210628164210.png" alt="cover"><br>Python 进阶学习笔记 当年学了点Python2 ，那时候听说什么Python3 失去了Python的灵魂，就没管Python3 。 最近因为项目需要使用Python3，又把当年的那份热血花在了Python3的学习上。 本以为Python3只是Python2 的升级会很好上手，没想到Python3相对于Python2而言有太多的新语法、新概念。 从小养成学习记笔记的好习惯，把学习遇到的重点写下来，第一日后复习用，其次如果有其他同学看到我的笔记，并感觉有用，也是算是我劳动成果的附加收益吧</p><span id="more"></span><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E6%96%B9%E6%B3%95%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD">方法(存储在内存中)</a></li><li><a href="#%E5%B1%9E%E6%80%A7property-def-funcself">属性（@property def func(self)）</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">创建类的两种方法</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8D%E5%8F%AF%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E4%BD%86%E6%98%AF%E5%90%8C%E4%B8%80%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%AD%89%E5%80%BCis--not-is%E5%88%A4%E6%96%AD">使用枚举类(枚举类不可比较大小，但是同一枚举类的成员可以做等值is / not is判断)</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB">定义枚举类</a></li></ul></li><li><a href="#%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">高级面向对象</a><ul><li><a href="#%E5%85%83%E7%B1%BBtypes">元类types</a></li><li><a href="#%E5%85%83%E7%B1%BBtype%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1">元类type构造对象</a></li><li><a href="#%E4%BD%BF%E7%94%A8slot%E9%99%90%E5%88%B6%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7">使用Slot限制添加属性</a></li><li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8">装饰器</a></li><li><a href="#python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">python垃圾回收机制</a></li></ul></li><li><a href="#python-%E5%BC%82%E5%B8%B8exception%E8%B0%83%E8%AF%95debug%E5%9B%9E%E6%BA%AFtraceback">python 异常（Exception）、调试（Debug）、回溯（Traceback)</a><ul><li><a href="#%E5%BC%82%E5%B8%B8exception">异常（Exception）</a></li><li><a href="#%E8%B0%83%E8%AF%95debug">调试（Debug）</a></li><li><a href="#%E5%9B%9E%E6%BA%AFtraceback">回溯（Traceback)</a></li></ul></li><li><a href="#with-%E7%94%A8%E6%B3%95">with 用法</a></li><li><a href="#f_string-%E5%A4%84%E7%90%86">f_string 处理</a></li><li><a href="#%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E7%9A%845%E7%A7%8D%E6%96%B9%E6%B3%95">数组复制的5种方法</a></li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li>高阶函数(参数里有函数类型)<blockquote><p>map/reduce(functools.reduce())<br>filter<br>sorted</p></blockquote></li><li>返回函数（返回函数类型）</li><li>匿名函数（<code>lambda</code>）</li><li>装饰器（<code>@：有参装饰器、无参装饰器,functools.wraps(function)</code>）</li><li>偏函数（<code>functools.partor(function[,args,**kwords]</code>)</li></ul><!--more--><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>1.静态字段<br>2.普通字段(self.value)</p></blockquote><h3 id="方法-存储在内存中"><a href="#方法-存储在内存中" class="headerlink" title="方法(存储在内存中)"></a>方法(存储在内存中)</h3><blockquote><p>1.普通方法def func(self[,args])<br>2.类方法(@classmethod def func(cls[,args]))<br>3.静态方法(@staticmethod def func())</p></blockquote><h3 id="属性（-property-def-func-self-）"><a href="#属性（-property-def-func-self-）" class="headerlink" title="属性（@property def func(self)）"></a>属性（@property def func(self)）</h3><blockquote><p>1.静态字段<br>2.装饰类</p><blockquote><p>经典装饰器<br>新装饰器(使用方法模拟成员变量以及对成员变量的操作)</p><p>方法一<br>继承object</p><pre><code class="python">@property             object.funcName //user funcName to get the function return value like member value@funcName.setter     object.func = value@funcName.deleter     del object.funcName</code></pre><p>方法二<br>创建property对象的静态字段</p><pre><code class="python">pro = property(get_value(),set_value(),del_value(),__doc__)obj = Object()ov = obj.proobj.pro = valuedel obj.proobj.pro.__doc__</code></pre></blockquote></blockquote><blockquote><p>类的特殊成员</p><ul><li><p><code>__doc__</code> 表示类的描述信息</p></li><li><p><code>__name__</code>类名</p></li><li><p><code>__bases__</code>类的所有父类构成的元组:tuple,不包含该类的type (类名即type类型使用<code>(my_class,)</code>可获得该类名的元组）</p></li><li><p><code>__mro__</code>类的继承顺序包含类本身&lt;class ‘__main__.My_class’&gt;, </p></li><li><p><code>__module__</code> 表示当前操作的对象在那个模块 packages.module</p></li><li><p><code>__class__</code> 表示当前操作的对象的类 packages.module.class</p></li><li><p><code>__init__()</code> 类的构造方法</p></li><li><p><code>__del__()</code> 类的析构方法</p></li><li><p><code>__call__()</code> 对象的方法 obj() self()</p></li><li><p><code>__getattr__()</code>当访问obj不存在的属性时会调用该方法  </p><p>getattr(obj, name, value)  ==&gt; obj.name 不存在该属性返回value</p><p>name是函数name()需要添加@property 描述符</p></li><li><p><code>__dict__</code> 类或对象中的所有成员</p></li><li><p><code>__str__</code> 将类格式化成字符串 print(obj) 时调用,即toString()方法</p></li><li><p><code>__repr__</code> 将类格式化成字符串 print(obj) 时调用,和 <code>__str__</code> 的区别：更适合从编程语言上理解 </p><blockquote><pre><code class="python">print(obj) [output:] class_name.method(self, arg1, arg2, ...)</code></pre></blockquote></li><li><p><code>__getitem__</code> 用于索引操作[num]，获取数据</p></li><li><p><code>__setitem__</code> 用于索引操作[num]，设置数据</p></li><li><p><code>__delitem__</code> 用于索引操作[num]，删除数据</p><blockquote><pre><code class="python">class mydict(object):    def __getitem__(self, key):         return self.key    def __setitem__(self, key, value):         self.key = value    def __delitem__(self, key):         del self.key         obj = mydict() result = obj[key] obj['key'] = value del obj['key']</code></pre></blockquote></li></ul></blockquote><blockquote><p><strong>实现切片操作</strong></p><blockquote><p><code>__getitem__(self, n)</code>传入的参数n 可能是int也可能是slice</p><pre><code class="python">class Fib(object):def __getiter__(self, n): if isinstance(n, int):       a, b = 1, 1       for x in range(n):           a, b = b, a + b     return a   if isinstanece(n, slice):       l = []       slice.start = 0 if (slice.start is None)       a, b = 1, 1       for x in range(n.stop):         if (x &gt;= n.start and (x - n.start)%n.step == 0):             l.append(a)           a, b = b, a+b       return l       </code></pre></blockquote><ul><li><p><code>__getslice__</code> (self, i, j) obj[-1:1]</p></li><li><p><code>__setslice__</code> (self, i, j, sequence) obj[0:1] = [11,22,33,44]</p></li><li><p><code>__delslice__</code> (self, i, j) del obj[0:2]</p></li><li><p><code>__iter__</code> 迭代器</p></li><li><p><code>__next__</code> 配合<code>__iter__</code>实现类的interable属性</p></li><li><p><code>__new__</code>方法<code>__new__(cls, name, bases, attrs)</code> 类准备将自身实例化时调用，在<code>__init__()</code>调用之前调用<code>__new__（）</code>，该方法是一个类方法@classmethod</p><p>cls：当前准备创建的类的对象:type</p><p>name：类的名字:str</p><p>bases：类继承的父类集合:class</p><p>attrs：类的方法集合:dict</p></li><li><p><code>__metaclass__</code> 该属性定义一个类的元类，即表示类该有哪个类（元类）来实例化</p></li></ul></blockquote><h3 id="创建类的两种方法"><a href="#创建类的两种方法" class="headerlink" title="创建类的两种方法"></a>创建类的两种方法</h3><blockquote><p>1.普通方法</p><pre><code class="python">class Object(object):   def func(self):      print('hello world!')object = Object()</code></pre><p>2.特殊方法（元类type构造对象）</p><pre><code class="python">def func(self):      print('Hello world!')  object = type('Object', (object,), {'func':func})#arg1:str 类名 ;arg2:tuple 基类; arg3:dict 成员;</code></pre><p><em><strong>类的创建过程</strong></em><br><img src="file:///C:/Users/LiuQixuan/Desktop/pypro/type_class.png" alt="类的创建过程"><br>【CODE】</p><pre><code class="python">class MyType(type):   def __init__(self, what, bases=None, dict=None):       super(MyType, self).__init__(what, bases, dict)   def __call__(self, *args, **kwargs):       obj = self.__new__(self, *args, **kwargs)       self.__init__(obj)class Foo(object):   __metaclass__ = MyType   def __init__(self, name):       self.name = name   def __new__(cls, *args, **kwargs):       return object.__new__(cls, *args, **kwargs)# 第一阶段：解释器从上到下执行代码创建Foo类# 第二阶段：通过Foo类创建obj对象obj = Foo()</code></pre></blockquote><h3 id="使用枚举类-枚举类不可比较大小，但是同一枚举类的成员可以做等值is-not-is判断"><a href="#使用枚举类-枚举类不可比较大小，但是同一枚举类的成员可以做等值is-not-is判断" class="headerlink" title="使用枚举类(枚举类不可比较大小，但是同一枚举类的成员可以做等值is / not is判断)"></a>使用枚举类(枚举类不可比较大小，但是同一枚举类的成员可以做等值is / not is判断)</h3><blockquote><pre><code class="python">from enum import Enummonth = Enum('Mouth',('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))for name ,member in month.__members__.items():  print(f'{name}=&gt;{member}=&gt;{member.value}')</code></pre></blockquote><h3 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h3><blockquote><pre><code class="python">from enum import Enum, unique@unique#unique装饰器帮助检查Enum内部字段，保证字段不重复class My_weekday(Enum):  Sun = 0  Mon = 1  Tue = 2  Wed = 3  Thu = 4  Fri = 5  Sat = 6 my_weekday = My_weekday()#my_weekday.Sunprint(my_weekday.Sun)#my_weekday.Sunprint(my_weekday['Sun'])#my_weekday.Sunprint(my_weekday(0))#my_weekday.Sunprint(my_weekday.Sun.value)#0for name, member in my_weekday.__members__.item():  print(f'{name} {member} {member.value}')【output】"""Sun  My_weekday.Sun 0Mon  My_weekday.Mon 1Tue  My_weekday.Tue 2Wed  My_weekday.Wed 3Thu  My_weekday.Thu 4Fri  My_weekday.Fri 5Sat  My_weekday.Sat 6"""</code></pre></blockquote><h2 id="高级面向对象"><a href="#高级面向对象" class="headerlink" title="高级面向对象"></a>高级面向对象</h2><h3 id="元类types"><a href="#元类types" class="headerlink" title="元类types"></a>元类types</h3><blockquote><p>动态地给对象添加方法(MethodType(func[, object/None], Object))</p><pre><code class="python">from types import MethodTypedef func(self, value):  self.age = valueclass Student(object):  def __init__(self,name):      self.name = namestudent = Student('Bob')student.age_setter = MethodType(age_setter,func)student.age_setter(21)print(f'{student.name}is {student.age} years old.')</code></pre><p>动态的给类添加方法</p><pre><code class="python">def func(self, value):      self.age = valueclass Student(object):      def __init__(self,name):          self.name = nameStudent.age_setter = funcStudent.age_setter = MethodType(func, None, Student)student = Student('Bob')student.age_setter(21)print(f'{student.name}is {student.age} years old.')</code></pre></blockquote><h3 id="元类type构造对象"><a href="#元类type构造对象" class="headerlink" title="元类type构造对象"></a>元类type构造对象</h3><blockquote><pre><code class="python">def func(self):      print('Hello world!')object = type('Object', (object,), {'func':func})#arg1:str 类名 ;arg2:tuple 基类; arg3:dict('a' = a, 'b' = b...) 类变量/静态字段;</code></pre></blockquote><h3 id="使用Slot限制添加属性"><a href="#使用Slot限制添加属性" class="headerlink" title="使用Slot限制添加属性"></a>使用Slot限制添加属性</h3><blockquote><p>slot是一个特殊静态字段,tuple类型.slot只对当前类起作用，对其子类并不起作用</p><pre><code class="python">class Student(object):      __slot__ = ('name', 'age')      def __init__(self, name, age):          super(Student,self).__init__()          self.name = name          self.age = age      @property      def name(self):          return self.name      @name.setter      def name(self,name):          self.name = name      @property      def age(self):          return self.age      @age.setter      def age(self,name):          self.age = ages1 = Student('Bill',21)s1.score = 89                [ERROR]:不能添加score字段</code></pre></blockquote><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote><p>一般装饰器（@decorate）</p></blockquote><blockquote><p>描述符装饰器</p><blockquote><p>实现了<code>__get__() __set__() __del__()@property @func.setter @func.deleter</code></p><p>数据描述符（实现了get set）<br>非数据描述符（只实现get 没有实现set)</p></blockquote></blockquote><h3 id="python垃圾回收机制"><a href="#python垃圾回收机制" class="headerlink" title="python垃圾回收机制"></a>python垃圾回收机制</h3><blockquote><ul><li>引用计数器（当一个对象被引用机会增加其引用计数，当不被引用时减少引用计数，减少至0时在合适的时机下内存被回收）</li><li>循环垃圾收集器（针对循环引用）</li><li>手动内存回收 del obj.obj (将引用计数置零，只有最后引用该内存的对象释放后才执行析构函数__del__())</li></ul></blockquote><h2 id="python-异常（Exception）、调试（Debug）、回溯（Traceback"><a href="#python-异常（Exception）、调试（Debug）、回溯（Traceback" class="headerlink" title="python 异常（Exception）、调试（Debug）、回溯（Traceback)"></a>python 异常（Exception）、调试（Debug）、回溯（Traceback)</h2><h3 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h3><blockquote><pre><code class="python">try:  passexcept Exception as e:  raiseelse:  passfinally:  pass</code></pre><h4 id="常见的异常："><a href="#常见的异常：" class="headerlink" title="常见的异常："></a>常见的异常：</h4><blockquote><table><thead><tr><th>异常名称</th><th>描述</th></tr></thead><tbody><tr><td>BaseException</td><td>所有异常K的基类</td></tr><tr><td>SystemExit</td><td>解释器请求退出</td></tr><tr><td>KeyboardInterrupt</td><td>用户自行中断执行^C</td></tr><tr><td>Exception</td><td>常规错误的基类</td></tr><tr><td>StopIteration</td><td>迭代器溢出</td></tr><tr><td>GeneratorExit</td><td>生成器发生异常后通知退出</td></tr><tr><td>StandardError</td><td>所有标准异常类的基类</td></tr><tr><td>ArithmeticError</td><td>所有数值计算错误的基类</td></tr><tr><td>FloattingPointError</td><td>浮点计算错误</td></tr><tr><td>OverflowError</td><td>数值运算溢出</td></tr><tr><td>ZeroDivisionError</td><td>除[,取模]by0</td></tr><tr><td>AssertionError</td><td>断言语句失败</td></tr><tr><td>AttributeError</td><td>对象缺失该属性</td></tr><tr><td>EOFError</td><td>没有内建输入，到达EOF标记</td></tr><tr><td>EnvironmentError</td><td>操作系统错误的基类</td></tr><tr><td>IOError</td><td>输入/输出操作失败</td></tr><tr><td>OSError</td><td>操作系统错误</td></tr><tr><td>WindowsError</td><td>系统调用失败</td></tr><tr><td>ImportError</td><td>导入模块/对象失败</td></tr><tr><td>LookupError</td><td>无效数据查询的基类</td></tr><tr><td>IndexError</td><td>序列中没有此索引</td></tr><tr><td>KeyError</td><td>映射中没有此键</td></tr><tr><td>MemoryError</td><td>内存溢出（对于Python解释起来说非致命）</td></tr><tr><td>NameError</td><td>未声明/初始化对象</td></tr><tr><td>UnboundLocalError</td><td>访问未初始化的本地变量</td></tr><tr><td>ReferenceError</td><td>试图访问已被回收器回收的对象（弱引用）</td></tr><tr><td>RuntimeError</td><td>一般运行时错误</td></tr><tr><td>NotImplementedError</td><td>尚未实现的方法</td></tr><tr><td>SyntaxError</td><td>Python语法错误</td></tr><tr><td>IndentationError</td><td>缩进错误</td></tr><tr><td>TabError</td><td>Tab和Space混用</td></tr><tr><td>SystemError</td><td>一般的解释器系统错误</td></tr><tr><td>TypeError</td><td>对类型无效的操作</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>UnicodeError</td><td>Unicode相关错误</td></tr><tr><td>UnicodeDecodeError</td><td>Unicode解码时的错误</td></tr><tr><td>UnicodeEncodeError</td><td>Unicode编码时的错误</td></tr><tr><td>UnicodeTranslateError</td><td>Unicode转码时的错误</td></tr><tr><td>Warning</td><td>警告的基类</td></tr><tr><td>DeprecationWarning</td><td>关于被弃用的特性的警告</td></tr><tr><td>FutureWarning</td><td>关于构造将来语义会有改变的警告</td></tr><tr><td>OverflowWarning</td><td>旧的关于自动提升为长整型(long)的警告</td></tr><tr><td>pendingDeprecationWarning</td><td>关于特性将会被废弃的警告</td></tr><tr><td>RuntimeWarning</td><td>可疑的运行时行为的警告</td></tr><tr><td>SysntaxWarning</td><td>可疑语法的警告</td></tr><tr><td>UserWarning</td><td>用户代码生成的警告</td></tr></tbody></table></blockquote></blockquote><h3 id="调试（Debug）"><a href="#调试（Debug）" class="headerlink" title="调试（Debug）"></a>调试（Debug）</h3><blockquote><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><blockquote><p>单元测试的类在unittest包中使用时直接导入包<code>import unittest</code>.</p><pre><code class="python">import unittestclass TestClass(unitest.TestCase): def setUp(self):       pass   def tearDown(self):       pass   def test_init(self):       self.assertEqual()       self.assertTrue()       self.assertRaises()   def test_func1(self):       pass   def test_func2(self):       pass</code></pre></blockquote><h4 id="文档测试-doctest"><a href="#文档测试-doctest" class="headerlink" title="文档测试(doctest)"></a>文档测试(doctest)</h4><blockquote><p>Python的文档测试模块可以直接提取注释中的代码并执行</p><pre><code class="python">class Dict(dict):   '''   Simple dict but also support access as x.y style.   &gt;&gt;&gt; d1 = Dict()   &gt;&gt;&gt; d1['x'] = 100   &gt;&gt;&gt; d1.x   100   &gt;&gt;&gt; d1.y = 200   &gt;&gt;&gt; d1['y']   200   &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3')   &gt;&gt;&gt; d2.c   '3'   &gt;&gt;&gt; d2['empty']   Traceback (most recent call last):       ...   KeyError: 'empty'   &gt;&gt;&gt; d2.empty   Traceback (most recent call last):       ...   AttributeError: 'Dict' object has no attribute 'empty'   '''   def __init__(self, **kw):       super(Dict, self).__init__(**kw)   def __getattr__(self, key):       try:           return self[key]       except KeyError:           raise AttributeError(r"'Dict' object has no attribute '%s'" % key)   def __setattr__(self, key, value):       self[key] = valueif __name__=='__main__':   import doctest   doctest.testmod()</code></pre></blockquote></blockquote><h3 id="回溯（Traceback"><a href="#回溯（Traceback" class="headerlink" title="回溯（Traceback)"></a>回溯（Traceback)</h3><blockquote><p>代码<br>以下代码功能相同</p><pre><code class="python">import tracebacktraceback.print_exc()traceback.format_exc()traceback.print_exception(*ss.exc_info())</code></pre></blockquote><h2 id="with-用法"><a href="#with-用法" class="headerlink" title="with 用法"></a>with 用法</h2><blockquote><p>事前事后用with（前后文管理器）</p><pre><code class="python">【version 1.0】file = open("/src/tmp.txt")data = file.read()file.close()  #可能会忘记关闭句柄#可能会出现异常【version 2.0】file = open("/src/tmp.txt")try:  data = file.read()finally:  file.close()#总体结构安全性都有提升【version 3.0 with】with open("/src/tmp.txt") as file:  data = file.read()</code></pre><p>with 对处理对象需要自定义<code>__enter__() __exit__()</code>方法</p><pre><code class="python">class Sample:def __enter__(self):  print('function:enter')  return "SAMPLE"   def __exit__(self, type, value, trace):      print('function:exit')def get_sample():  return Sample()with get_sample() as sample:  print(f'{sample}do somethings')[result:]function:enterSAMPLE do somethingsfunction:exitclass Sample:def __init__(self, value):  self.num = valuedef __enter__(self):  print('function:enter')  return self   def __exit__(self, type, value, trace):      print('function:exit')      print('m_type:{type}\tm_value:{value}\ttrace:{trace})   def func(self, value):      return self.num/valuedef get_sample(num):return Sample(num)with get_sample() as sample:  print(f'{sample}do somethings')  num = input("input a number:")  sample.func(num)#执行顺序：#with 后面的函数/或type对象使用类的__init__()创建出一个对象,然后调用__enter__()方法将返回值赋给as 后的变量。在with执行完毕后调用类中的__exit__（）方法，清理或关闭句柄。</code></pre><ul><li><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</li></ul></blockquote><h2 id="f-string-处理"><a href="#f-string-处理" class="headerlink" title="f_string 处理"></a>f_string 处理</h2><p><code>__str__，__repr__</code></p><blockquote><ul><li><code>__str __（）</code>和<code>__repr __（）</code>方法处理对象如何呈现为字符串，因此您需要确保在类定义中包含至少一个这些方法。如果必须选择一个，请使用<code>__repr __（）</code>，因为它可以代替<code>__str __（）</code>。</li><li><code>__str __（）</code>返回的字符串是对象的非正式字符串表示，应该可读。<code>__repr __（）</code>返回的字符串是官方表示，应该是明确的。调用<code>str（）</code>和<code>repr（）</code>比直接使用<code>__str __（）</code>和<code>__repr __（）</code>更好。</li><li>默认情况下，f字符串将使用<code>__str __（）</code>，但如果包含转换标志<code>!r</code>，则可以确保它们使用<code>__repr __（）</code>。</li></ul><pre><code class="python">f"{new_comedian}"'This __str__'f"{new_comedian!r}"'This __repr__'</code></pre></blockquote><h2 id="数组复制的5种方法"><a href="#数组复制的5种方法" class="headerlink" title="数组复制的5种方法"></a>数组复制的5种方法</h2><p>python中简单将一个数组赋值给另一个数组,实际上是两个引用指向同一块内存,可能无法达到预期目的.因此这里整理了几种数组拷贝复制的方法.</p><blockquote><ol><li><p>切片</p><pre><code class="python">newArr = oldArr[:]</code></pre></li><li><p>list()</p><pre><code class="python">newArr = list(oldArr)</code></pre></li><li><p>Arr*1</p><pre><code class="python">newArr = oldArr*1</code></pre></li><li><p>copy.copy()浅拷贝方法</p><pre><code class="python">newArr = copy.copy(oldArr)newArr = oldArr.copy()</code></pre></li><li><p>copy.deepcopy()深拷贝方法</p><pre><code class="python">newArr = copy.deepcopy(oldArr)</code></pre></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> noteBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/28/hello-world/"/>
      <url>/2021/06/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
